# 저장소와 검색

데이터베이스가 하는 역할을 단순화 해보면, 데이터를 저장하고 후에 해당 데이터를 불러오는 역할이다. 다음의 간단한 예시를 살펴보자

<details>
  <summary>간단한 File Database 예시</summary>
  <div markdown="1">

```bash
#!/bin/bash

db_set() {
  echo "$1,$2" >> database
}

db_get() {
  grep "^$1," database | sed -e "s/^$1,//" | tail -n 1
}
```

  </div>
</details>

위와 같은 형식으로 구현된 대표적인 데이터베이스가 로그(log)이다. 위의 데이터베이스는 write 기능은 크게 비효율적이지 않지만, 읽기 기능의 효율성은 O(n) 이다. 이러한 비효율을 해결하기 위한 도구가 Index 이다.

Index는 기본 데이터에서 파생된 추가적인 구조이다. Index 는 원본 데이터에는 영향을 미치지 않으며, 쿼리 성능에만 영향을 준다. 보통의 경우, Index 는 질의 성능을 개선시키고, 쓰기 성능은 하락시킨다.

### 해시 색인

키-값 저장소는 대부분의 프로그래밍 언어에서 볼 수 있는 Dictionary Type 과 유사하다. 디스크 상의 데이터를 색인하기 위해 인메모리 데이터 구조를 사용하는 것은 어떨까 ?

키를 데이터 파일의 바이트 오프셋에 매핑해 인메모리 해시 맵을 유지하는 전략이다. 파일에 새로운 키-값 쌍을 추가할 때마다 방금 기록한 데이터의 오프셋을 반영하기 위해 해시맵도 갱신해야 한다. 해시 테이블은 많이 사용되는 Index 구조이지만, 제약 사항이 있다.

- 해시 테이블은 메모리에 저장해야 하므로 키가 너무 많으면 문제가 된다. 원칙적으로는 디스크에 해시 맵을 유지할 수 있지만, 디스크 상의 해시맵에 좋은 성능을 기대하긴 어렵다. 무작위 접근 IO 가 많이 필요하고 디스크가 가득 찼을 때 확장하는 비용이 비싸다.
- 범위 질의(range query) 에 효율적이지 않다.

### SS테이블과 LSM 트리

이제 세그먼트 파일의 형식에 간단한 변경사항 한 가지를 적용해 보자. 일련의 키-값 쌍을 키로 정렬하는 것이다. 이처럼 키로 정렬된 형식을 `정렬된 문자열 테이블(Sorted String Table)` 또는 `SS테이블이라 부른다.`

- 세그먼트 병합은 파일이 사용 가능한 메모리보다 크더라도 간단하고 효율적이다. 입력 파일을 함께 읽고, 각 파일의 첫 번째 키를 기록해 둔다. 이 키는 후에 원하는 데이터를 찾아가는 데에 사용된다.
- 읽기 요청은 요청 범위 내에서 여러 키-값 쌍을 스캔해야 하기 때문에 해당 레코드들을 블록으로 그룹화하고 디스크에 쓰기 전에 압축한다. 인메모리 색인의 각 항목은 압축된 블록의 시작점을 가리키게 된다. 압축을 활용하면 디스크 공간을 절약한다는 점 외에도 IO 대역폭 사용도 줄인다.

### SS테이블 생성과 유지

저장소 엔진을 다음과 같이 만들 수 있다.

- 쓰기가 들어오면 인메모리 균형 트리(balanced tree) 데이터 구조에 추가한다. 이 인메모리 트리는 멤테이블(memtable)이라고도 한다.
- 멤테이블이 보통 수 메가바이트 정도의 임곗값보다 커지면 SS테이블 파일로 디스크에 기록한다. 트리가 이미 키로 정렬된 키-값 쌍을 유지하고 있기 때문에 효율적으로 수행할 수 있다. 새로운 SS테이블 파일은 데이터베이스의 가장 최신 세그먼트가 된다. SS테이블을 디스크에 기록하는 동안 쓰기는 새로운 멤테이블 인스턴스에 기록한다.
- 읽기 요청을 제공하려면 먼저 멤테이블에서 키를 찾아야 한다. 그다음 디스크 상의 가장 최신 세그먼트에서 찾는다. 그다음으로 두 번째 오래된 세그먼트, 세 번째 오래된 세그먼트 등에서 찾는다.
- 가끔 세그먼트 파일을 합치고 덮어 쓰여지거나 삭제된 값을 버리는 병합과 컴팩션 과정을 수행한다. 이 과정은 백그라운드에서 수행된다

### SS테이블에서 LSM 트리 만들기

원래 위의 색인 구조는 로그 구조화 병합 트리(Log-Structured Merge-Tree) 란 이름으로 패트릭 오닐이 발표했다. 정렬된 파일 병합과 컴팩션 원리를 기반으로 하는 저장소 엔진을 LSM 저장소 엔진이라 부른다. Lucene 은 용어 사전을 저장하기 위해 유사한 방법을 사용한다.

### 성능 최적화

- LSM 트리 알고리즘은 DB 에 존재하지 않는 키를 찾는 경우 느릴 수 있다. 멤테이블을 확인한 다음 키가 존재하지 않는다는 사실을 가장 오래된 세그먼트까지 거슬러 올라가야 하기 떄문이다. 이러한 접근을 최적화하기 위해 `블룸 필터`를 추가적으로 사용한다. 블룸 필터는 키가 DB 에 존재하지 않음을 알려주므로 존재하지 않는 키를 위한 불필요한 디스크 읽기를 많이 절약할 수 있따.
- 또한 SS테이블을 압축하고 병합하는 순서와 시기를 결정하는 다양한 전략이 있다.

LSM 트리의 기본 개념은 백그라운드에서 연쇄적으로 SS테이블을 지속적으로 병합하는 것이다. 이 개념은 데이터셋이 가능한 메모리보다 훨씬 더 크더라도 여전히 효과적이다. 데이터가 정렬된 순서로 저장돼 있다면 범위 질의를 효율적으로 실행할 수 있다.

### B트리

가장 널리 사용되는 색인 구조는 B트리로 구조가 로그 구조화 색인과는 상당히 다르다. 앞에서 살펴본 로그 구조화 색인은 데이터베이스를 일반적으로 수 메가바이트 이상의 가변 크기를 가진 `세그먼트`로 나누고 항상 순차적으로 세그먼트를 기록한다. 반면 B트리는 전통적으로 4KB 크기의 고정 크기 블록이나 페이지로 나누고 한 번에 하나의 페이지에 읽기 또는 쓰기를 한다.
각 페이지는 주소나 위치를 이용해 식별할 수 있다.

- 한 페이지는 B트리의 루트(root) 로 지정된다. 색인에서 키를 찾으려면 루트에서 시작한다.
- 페이지는 여러 키와 하위 페이지의 참조를 포함한다.
- 최종적으로는 개별 키(리프 페이지(leaf page)) 를 포함하는 페이지에 도달한다. 이 페이지는 각 키의 값을 포함하거나 값을 찾을 수 있는 페이지의 참조를 포함한다.
- B트리의 한 페이지에서 하위 페이지를 참조하는 수를 분기 계수(branching fGtor) 라고 부른다.
- B트리에 존재하는 키의 값을 갱신하려면 키를 포함하고 있는 리프 페이지를 검색하고 페이지의 값을 바꾼 다음 페이지를 디스크에 다시 기록한다.
- 새로운 키를 수용한 페이지에 충분한 여유 공간이 없다면 페이지 하나를 반쯤 채워진 페이지 둘로 나누고 상위 페이지가 새로운 키 범위의 하위 부분들을 알 수 있게 갱신한다.

이 알고리즘은 트리가 계속 균형을 유지하는 것을 보장한다. n개의 키를 가진 B트리는 깊이가 항상 `O(log n)` 이다.

### 신뢰할 수 있는 B트리 만들기

B트리의 기본적인 쓰기 동작은 새로운 데이터를 디스크 상의 페이지에 덮어쓴다. LSM 트리는 파일에 추가만 할 뿐 기존의 파일은 변경하지 않는다는 점에서 차이가 있다.

### B트리와 LSM 트리 비교

경험적으로 LSM 트리는 보통 쓰기에 더 빠른 반면 B트리는 읽기에서 더 빠르다. 읽기가 보통 LSM 트리에서 더 느린 이유는 컴팩션 단계에 있는 여러 가지 데이터구조와 SS테이블을 확인해야 하기 때문이다.

### LSM 트리의 장점

LSM 트리는 보통 B트리보다 쓰기 처리량을 높게 유지할 수 있다. LSM 트리는 압축률이 좋아, B트리보다 쓰기 처리량을 높게 유지할 수 있다.

### LSM 트리의 단점

- 때로는 컴팩션 작업이 진행중인 읽기와 쓰기의 성능에 영향을 준다.

### 기타 색인 구조

- Primary Key
  - 관계형 테이블에서 하나의 로우를 식별하는 데 사용된다.
- Secondary Index
  - 보조 색인은 주로 효율적으로 조인을 수행하는 데 결정적인 역할을 한다.
  - 보조 색인은 키-값 색인에서 쉽게 생성할 수 있다. 다만, 같은 키를 가진 많은 로우가 존재할 수 있다.
- 색인 안에 값 저장하기
  - 색인의 키는 다음의 두 가지 중 하나이다.
    - 실제 로우
    - 다른 곳에 저장된 로우를 가리키는 참조
      - 실제 로우가 저장되어있는 파일을 Heap File 이라고 한다.
      - 색인에서 Heap File 로 이동하는 과정에도 Cost 가 있기 때문에, 어떤 상황에서는 색인 안에 바로 색인된 로우를 저장하는 편이 바람직하다. 이를 `Clustered Index` 라 부른다.
      - Mysql 의 InnoDB 에서는 테이블의 PK 가 Clustered Index 이고, 보조 색인은 힙 파일의 위치가 아닌 PK 를 참조한다.
- 전문 검색과 퍼지 색인
  - 철자가 틀린 단어와 같이 유사한 키에 대한 애매모호한 질의에서는 다른 기술이 필요하다.
  - 루씬은 문서나 질의의 오타에 대처하기 위해 특정 편집 거리(edit distance) 내 단어를 검색할 수 있다.

### 모든 것을 메모리에 보관

램의 가격이 점점 저렴해져서, 인메모리 데이터베이스가 개발되었다.

### 트랜잭션 처리와 분석 시스템

| 특성           | 트랜잭션 처리 시스템(OLTP)                       | 분석 시스템(OLAP)                        |
| -------------- | ------------------------------------------------ | ---------------------------------------- |
| 주요 읽기 패턴 | 질의당 적은 수의 레코드, 키 기준으로 가져옴      | 많은 레코드에 대한 집계                  |
| 주요 쓰기 패턴 | 임의 접근, 사용자 입력을 낮은 지연 시간으로 기록 | 대규모 불러오기(bulk) 또는 이벤트 스트림 |
| 주요 사용처    | 웹 어플리케이션을 통한 최종 사용자/소비자        | 의사결정 지원을 위한 내부 분석가         |
| 데이터 표현    | 데이터의 최신 상태(현재 시점)                    | 시간이 지나며 일어난 이벤트 이력         |
| 데이터셋 크기  | 기가바이트에서 테라바이트                        | 테라바이트에서 페타바이트                |

### 분석용 스키마: 별 모양 스키마와 눈꽃송이 모양 스키마

분석용 DB 에서는 소위 사실 테이블(fact table)과 차원 테이블(dimension table) 이 존재한다. 보통 사실은 개별 이벤트를 담는다. 사실 테이블의 다른 칼럼은 차원 테이블을 가리키는 왜래 키 참조이다. 별 모양 스키마란 이름은 테이블 관계가 시각화될 때 사실 테이블이 가운데에 있고 차원 테이블로 둘러싸고 있다는 사실에서 비롯됐다.

### 칼럼 지향 저장소

```sql
SELECT
    dim_date.weekday, dim_product.category,
    SUM(fact_sales.quantity) AS quantity_sold
FROM fact_sales
    JOIN dim_date ON fact_sales.date_key = dim_date.date_key
    JOIN dim_product ON fact_sales.product_sk = dim_product.product_sk
WHERE dim_rate.year = 2013 AND
    dim_product.category IN ('Fresh fruit', 'Candy')
GROUP BY
    dim_date.weekday, dim_product.category;
```

대부분의 OLTP 데이터베이스에서 저장소는 row 지향적으로 데이터를 배치한다. 문서형 데이터베이스에서도 전체 문서는 보통 하나의 연속된 바이트 열로 저장한다. row 지향 데이터베이스에서 위의 쿼리를 실행하려면, 모든 로우를 메모리로 적재한 다음 구문을 해석해 필요하지 않은 로우를 필터링해야 한다. 이 작업은 오래 걸릴 수 있다.

`칼럼 지향 저장소`의 개념은 간단하다. 모든 값을 하나의 로우에 함께 저장하지 않는 대신, 각 칼럼별로 모든 값을 함께 저장한다. 각 칼럼을 개별 파일에 저장하면 질의에 사용되는 칼럼만 읽고 구문 분석하면 된다.

#### 칼럼 압축

데이터 웨어하우스에서 특히 비트맵 부호화(bitmap encoding) 을 통해 저장소를 압축할 수 있다.
