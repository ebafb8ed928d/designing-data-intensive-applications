# 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션
* Application을 제한하는 요소
  * 데이터의 양, 데이터의 복잡도, 데이터의 변화 속도
  * 데이터베이스, 캐시, 검색 색인, 스트림 처리, 일괄 처리
## 데이터 시스템에 대한 생각
* 작업(work)은 태스크(task)로 나누기
* 다양한 도구들은 애플리케이션 코드를 이용해 서로 연결

## 신뢰성
* 애플리케이션은 사용자가 기대한 기능을 수행한다.
* 시스템은 사용자가 범한 실수나 예상치 못한 소프트웨어 사용법을 허용할 수 있다.
* 시스템 성능은 예상된 부하와 데이터 양에서 필수적인 사용 사례를 충분히 만족한다.
* 시스템은 허가되지 않은 접근과 오남용을 방지한다.
> 올바르게 동작함 - 무언가 잘못되더라도 지속적으로 올바르게 동작함
### 결함
* 잘못될 수 있는 일
* 결함을 예측하고 대처할 수 있는 시스템 == **내결함성/탄력성**을 가진 시스템
* 넷플릭스의 카오스 몽키
#### 하드웨어 결함
* 하드웨어 시스템 장애율을 줄이기
  * 하드웨어 구성 요소에 중복 추가
    * 디스크는 RAID
    * 서버는 이중 전원 다바이스, 핫스왑 가능한 CPU
    * 데이터 센터는 건전지와 예비 전원용 디젤 발전기
  → 구성요소 하나가 죽으면 고장난 구성요소가 교체되는 동안 중복된 구성 요소를 대신 사용
* AWS와 같은 클라우드 플랫폼을 사용한 설계
#### 소프트웨어 오류
* 예상하기 어려움
* 노드 간 상관관계 때문에 시스템 오류를 더욱 많이 유발
  * 잘못된 특정 입력이 있을 때, 모든 애플리케이션 서버 인스턴스가 죽는 소프트웨어 버그
  * CPU 시간, 메모리, 디스크 공간, 네트워크 대역폭처럼 공유 자원을 과도하게 사용하는 일부 프로세스
  * 시스템의 속도가 느려져 반응이 없거나 잘못된 응답을 반환하는 서비스
  * 한 구성 요소의 작은 결함이 다른 구성 요소의 결함을 야기하고, 차례차례 더 많은 결함이 발생하는 연쇄 장애
* 소프트웨어의 체계적 오류 문제는 신속한 해결책이 없다.
* 시스템의 가정과 상호작용에 대해 주의 깊게 생각하기, 빈틈 없는 테스트, 프로세스 격리, 죽은 프로세스의 재시작 허용, 프로덕션 환경에서 시스템 동작의 측정, 모니터링, 분석하기
#### 인적 오류
* 오류의 가능성을 최소화 하는 방향으로 시스템 설계
* sandbox stage
* 테스트 보강
* 롤백/롤아웃, 데이터 재계산 도구 제공
* 성능 지표와 오류율 같은 상세하고 명확한 모니터링 대책 마련 (원격 측정)
* 조작 교육과 실습 시행

## 확장성
* 증가한 부하에 대처하는 시스템 능력
### 부하 기술하기
* **부하 매개변수**
  * 웹 서버의 초당 요청 수, 데이터베이스의 읽기 대 쓰기 비율, 대화방의 동시 활성 사용자, 캐시 적중률 등
#### 트위터의 부하 매개 변수
> 1. 트윗 작성: 평균 초당 4.6k 요청, 피크일 때 초당 12k 요청 이상 
> 2. 홈 타임라인: 초당 300k 요청
* 접근 방식 A 
  * 간단히 새로운 트윗을 트윗 전역 컬렉션에 삽입
  * 사용자의 홈 타인라인을 요청 → 팔로우하는 모든 사람 찾기 → 트윗을 찾아 시간순으로 정렬 후 합치기
  ```sql
  select tweets.*, users.* from tweets
      join users on tweets.sender_id = users.id
      join follows on follows.followee_id = user.id
      where follows.follower_id = current_user
  ```
* 접근 방식 B
  * 개별 사용자의 홈 타인라인 캐시 유지 (읽기 비용 절감)
  * 트윗 작성 → 팔로우 하는 사람 모두 찾기 → 팔로워 각자의 홈 타인라인 캐시에 새로운 트윗 삽입
    * 읽기 요청은 결과를 미리 계산했으므로 비용 저렴
> 평균적으로 트윗 게시 요청량이 홈 타임라인 읽기 요청량에 비해 수백배 적기 때문에, 접근 방식 2가 훨씬 잘 동작
> 쓰기 시점에는 더 많은 일을 하고, 읽기 시점에 적은 일을 하기!
* 평균적으로 트윗이 약 75명의 팔로워에게 전달되므로, 초당 4.6k 트윗은 홈 타임라인 캐시에 초당 345k 쓰기가 된다.
* but, 사용자마다 팔로워수가 다르므로, 3천만명이 넘는 팔로워를 가진 사용자의 경우 해당 사용자가 트윗 하나를 올리면 팔로워 3천만명의 타임라인에 쓰기 요청을 보내기 된다.
* 이 때, 사용자당 팔로워의 분포는 팬아웃 부하를 결정하는 핵심 부하 매개변수가 된다.
> 트위터의 해결 방식은, A+B 방식의 hybrid
> 대부분 사용자의 트윗은 홈 타임라인에 펼쳐지지만, 팔로워 수가 매우 많은 소수 사용자는 팬아웃에서 제외
### 성능 기술하기
* 부하 매개변수를 증가시키고 시스템 자원을 유지하면?
* 부하 매개변수를 증가시켰을 때 성능이 변하지 않고 유지되려면?
#### 처리량
* 초당 처리할 수 있는 레코드수나 일정 크기의 데이터 집합으로 작업을 수행할 때 걸리는 전체 시간에 관심
  * 예) Hadoop과 같은 일괄 처리 시스템
#### 응답시간
* 클라이언트가 요청을 보내고 응답을 받는 사이의 시간
  * 예) 온라인 API
* 클라이언트가 동일한 요청을 하더라도, 매번 응답 시간이 다름
  * 단일 숫자가 아니라 측정 가능한 값의 **분포**
* 특이 값 (Outlier)
  * 대부분의 응답 시간에 비해 꽤 오래걸리는 응답 값
  * 95분위, 99분위, 99.9분위 (p95, p99, p999)
* 평균
  * 산술 평균
  * 전형적인 응답 시간을 알고 싶다면, 좋은 지표가 아님.
  * 얼마나 많은 사용자가 실제로 지연을 경험했는지 알 수 없다.
* 백분위
  * **중앙 값**
    * 사용자가 얼마나 오랫동안 기다려야하는 지 알고 싶을 때
    * 절반은 중앙값 응답 시간 미만으로 제공, 나머지 반은 중앙값 보다 오래 걸림
    * 50분위로서 p50으로 축약
  * 꼬리 지연 시간
    * 상위 백분위 응답 시간
    * 사용자 경험에 직접 영향을 주기 때문에 중요
  * SLO, SLA
### 부하 대응 접근 방식
* 용량 확장
  * 수직 확장
  * 좀 더 강력한 장비로 이동
* 규모 확장
  * 수평 확장
  * 다수의 낮은 사양 장비에 부하를 분산
* 탄력적인 시스템
  * 부하 증가를 감지하면 컴퓨팅 자원을 자동으로 추가
  * stateless/stateful 서비스
    * 비저장 서비스를 배포하는 일은 상당히 간단
    * 상태 유지 시스템을 분산 설치하는 일은 복잡도가 발생
 → 확장 비용이나 데이터베이스를 분산으로 만들어야 하는 고가용성 요구가 있을 때까지, 단일 노드에 데이터 베이스를 유지하는 것(용량 확장)이 최근까지의 통념
* 애플리케이션의 주요 동작이 무엇인지? 잘 하지 않는 동작이 무엇인지?에 대한 가정을 바탕으로 구축
> 매개변수를 고려해 확장하는 작업이 중요

## 유지보수성
* 소프트웨어 비용의 대부분은 유지보수에 들어간다.
  * 버그 수정, 시스템 운영 유지, 장애 조사, 새로운 플랫폼 적응 등등등..
* 소프트웨어 시스템 설계 원칙 
  * 운용성
    * 시스템을 원활화게 운영할 수 있도록 쉽게 만들기
  * 단순성
    * 시스템 복잡도 제거
    * 엔지니어가 시스템을 이해하기 쉽게 만들기
  * 발전성
    * 시스템 변경이 쉽도록 하기
    * = 유연성, 수정 가능성, 적응성
### 운용성: 운영의 편리함 만들기
* 좋은 운영성이란? 동일하게 반복되는 task를 쉽게 수행하게끔 만들어 운영팀이 고부가가치 활동에 노력을 집중
  * 좋은 모니터링으로 런타임 동작과 시스템 내부에 대한 가시성 제공
  * 표준 도구를 이용해 자동화와 통합을 위한 우수한 자원 제공
  * 개별 장비 의존성 회피
  * 좋은 문서와 이해하기 쉬운 운영 모델
  * 만족할만한 기본 동작 제공, 필요할 때 기본값을 다시 정의할 수 있는 자유 부여
  * self-healing, 필요에 의한 수동제어 가능
  * 예측 가능한 동작
### 단순성: 복잡도 관리
* tight coupling, 복잡한 의존성, 일관성 없는 명명과 용어, 성능 문제 해결을 목표로 한 해킹, 임시방편으로 문제를 해결한 특수 사례 등
* 우발적 복잡도 줄이기 
  * 좋은 추상화
    * 깔끔하고 직관적인 외관 아래로 많은 세부 구현을 숨길 수 있다.
    * 재사용을 통한 효율적, 고품질의 소프트웨어
### 발전성: 변화를 쉽게 만들기 
* agile
  * tdd
  * refactoring
* 데이터 시스템 변경을 쉽게 하고 변화된 요구사항에 시스템 맞추기

